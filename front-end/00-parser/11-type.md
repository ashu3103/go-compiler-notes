# Type Expression

When the Go compiler encounters a type expression which could be a simple type like `int`, a complex type like `[]map[string]*User`, or an embedded type name, it runs the `typeOrNil` routine. This routine acts like a detective, checking the very first token to figure out what kind of type it's looking at, then recursively parsing the rest.

## Grammer

```
Type     = TypeName | TypeLit | "(" Type ")" .
TypeName = identifier | QualifiedIdent .
TypeLit  = ArrayType | StructType | PointerType | FunctionType | InterfaceType | SliceType | MapType | Channel_Type
```

## Parsing

|Token                              |Type Being Parsed                                                                                                                                                                                                                                                                       |Example                            |Parser Action                                      |
|-----------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------|---------------------------------------------------|
|`_Star` (`*`)                          |Pointer Type                                                                                                                                                                                                                                                                            |`*User`                              |Unary Recursion: Consumes the `*`. The rest of the expression (User) must also be a type expression, which is parsed recursively. The result is a unary expression with operator `_Mul` and `X` equals the (parsed) type expression.|
|`_Arrow` (`<-`)                        |Receive Channel Type                                                                                                                                                                                                                                                                    |`<-chan int`                         |Dedicated Channel: Consumes `<-`, then demands the next token be `_Chan`. It sets the channel direction to Receive Only (RecvOnly) and recursively parses the element type (`int`). The result is a `ChanType` expression with its direction (`Dir` field) set to `RecvOnly` and `Elem` field set to (parsed) type expression .|
|`_Lbrack` (`[`)                        |Slice or Array Type                                                                                                                                                                                                                                                                     |`[]string` or `[5]int`                 |Lookahead Decision: Consumes `[`. If the very next token is `_Rbrack` (`]`), it's a Slice Type (`[]`). Otherwise, the parser knows it must be an Array Type (`[N]`). It parses the array length (`N`), consumes `]`, and then parses the element type recursively. The routine concludes by returning either a `SliceType` or an `ArrayType`. Both structures define the element type (`Elem`), but the `ArrayType` uniquely includes the parsed length expression in its `Len` field |
|`_Chan` (`chan`)                       |Send,Receive or Unbuffered Channel                             |`chan<- bool` or `chan int`|Lookahead Decision: Consumes `chan`. It checks if the next token is `_Arrow` (`<-`). If so, it sets the direction (`Dir` field) of `ChaType` expression to Send Only (SendOnly). If not, the channel is bidirectional/unbuffered. Finally, it parses the element type recursively and flows it to the corresponding `Elem` field.|
|`_Map` (`map`)                         |Map Type                                                                                                                                                                                                                                                                                |`map[int]string`                     |Key and Value: Consumes map. It demands `_Lbrack` (`[`), parses the Key Type (field of `MapType`) (say `int`), demands `_Rbrack` (`]`), and then parses the Value Type (say `string`). Returns the `MapType` expression |
|`_Struct` (`struct`)                   |Struct Type                                                                                                                                                                                                                                                                             |`struct { Name string }`             |Field List Handlers: The parser calls dedicated functions (`p.structType()`) that then use the Field Declaration grammar to populate the list of fields and tags within the struct body (`{...}`). Returns the `StructType` expression |
|_Interface (interface)             |Interface Type                                                                                                                                                                                                                                                                          |interface { Read() int }           |Method List Handlers: The parser calls a dedicated function (p.interfaceType()) to read and parse the list of method signatures.|
|`_Name` (identifier)                 |Named or Qualified Type                                                                                                                                                                                                                                                                 |`MyType` or `net.Conn`                 |Name Resolution: Parses the identifier. If it contains a dot (`.`), it's a Qualified Ident (referencing a type in another package, like `net.Conn`). If it's a single name, it's a local Named Type (`MyType`). Basically, returns the expression obtained by resolving qualified name see (TODO<link>) |
|`_Lparen` (`(`)                        |Parenthesized Type                                                                                                                                                                                                                                                                      |`(*int)`                             |Grouping: Consumes `(`. Recursively parses the type expression inside (say `*int`), then demands `_Rparen` (`)`). The parentheses themselves are usually discarded unless they are required for semantic checks (which is often configurable).|


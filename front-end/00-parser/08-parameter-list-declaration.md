# Parameter List

A procedure in the Go parser (`paramList`) is responsible for consuming a complete list of parameters (or results) in a function signature, method signature, or type parameter list. Its main complexity is distributing the type across a list of names, such as in `(a, b int)`.

## Grammer

The function primarily parses two related grammar rules for function parameters:

```
Parameters    = "(" [ ParameterList [ "," ] ] ")"
ParameterList = ParameterDecl { "," ParameterDecl }
ParameterDecl = [ IdentifierList ] [ "..." ] Type
```

Th function assumes that the parser has already consumed a `_LParen` before being called and the body of the `paramList` function handles the tokens within the parentheses ((`...`) for regular parameters).

The core element it processes is the parameter declaration, which is generated by `p.paramDeclOrNil`. This declaration can be:

- Named Parameter: IdentifierList Type (e.g., `a, b int`)
- Unnamed Parameter: Type (e.g., `User`)
- Variadic Parameter: ... Type (e.g., `...string`)

## Parsing

The `paramList` function operates in three distinct phases to ensure every parameter has both a name and a type, and that constraints are correctly positioned.

**Phase A:** Token Consumption (Left-to-Right)

Essentially, the parser uses the first token encountered to determine if the resulting field is named or unnamed, and subsequently resolves its type.

The parser iteratively consumes comma-separated field items using the `p.list` helper function until it reaches the closing delimiter (e.g., `)`). For each item, the parser follows a two-part decision tree:

1 Named Field

If the first token consumed is an identifier, the field is considered named (the field.Name property is set). The parser then looks ahead at the next token to determine the nature of the associated type:

| Token  | Action  | Resulting Field Type | Example Handled |
| ------ | ------- | --------------- | ----- |
| `_LBrack` (`[`) |   Parses Array, Slice or Type Argument | Named & Typed    | `a []int` or `a [5]rune`  |
| `_Dot` (`.`) | Parses a Qualified Identifier | Named & Typed | `pkg.Type` |
| `_DotDotDot` (`...`) | Consumes `...`. Recursively calls `p.typeOrNil()` for the element type. Returns a `DotsType` AST node | Named & Type | `...string` |
| otherwise | Attempts to parse a type expression using `p.typeOrNil()`. | Named & Typed (if a type is successfully parsed) or Named & Untyped (if parsing fails, meaning only the identifier name was present). | `int` or `Address` |


2 Unnamed Field

If the item does not start with an identifier, the parser assumes the entire expression represents an unnamed type. It then checks for an optional variadic marker (`...`) before attempting to parse the full type expression:

- Check for Variadic (`...`): If `...` is found first, it parses the element type and returns a `DotsType` node.
- Parse Simple Type: Otherwise, it simply calls `p.typeOrNil()` to parse a standard type expression (e.g., `int` or `*Address`).

In both of these sub-cases, the field is returned as Unnamed and Typed.

**Phase B:** Post-Processing and Type Propagation (Right-to-Left Sweep)

After consuming all tokens, the parser must now fix the list to ensure implicit types are correctly assigned. This is necessary when an identifier list shares a single type.

If the number of named fields (named) is less than the total number of fields (`len(list)`), a right-to-left sweep is performed:

* Initialization: It starts at the last parameter (the rightmost one). The variable `typ` is initialized to `nil`.
* Iteration: It iterates backward through the list.
   * If the current parameter (par) has a Type: This type becomes the new working type (`typ = par.Type`). This type will be propagated to all preceding parameters that lack an explicit type. If the parameter lacked a name (e.g., an unnamed return value like (`int`)), its name is automatically set to `_`.
   * If the current parameter (`par`) lacks a Type: The current working type (`typ`) is assigned to it (`par.Type = typ`). This correctly distributes the type from right to left.

This sweep ensures that in the expression `(a, b, c int)`, the type int found at `c` is successfully copied back to `b` and then to `a`.

**Phase C:** Variadic Check

Finally, the parser iterates through the now-complete list to check for the correct placement of the variadic operator (`...`).

- **Rule:** The `...` operator, which results in a `*DotsType`, is only valid if the Field containing it is the last item in the ParameterList.
- **Check:** The code checks if the parameter (`f`) contains a DotsType and if it is not the last element (`i+1 < len(list)`). If this condition is met, an error is reported ("can only use `...` with final parameter"), and the `...` is removed from the type to allow the AST construction to continue.



